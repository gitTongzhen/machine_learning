RCNN的思路
卷积神经网络已经帮助我们完成了图像识别的任务，我们接下下来，只需要添加一些额外的功能来完成定位即可。
定位的问题解决思路有哪些
## 思路一:
将定位的问题看作是回归的问题，我们需要预测出四个参数的位置，然后得到方框的位置
![avatar](./docs/rcnn.png)
该思路的步骤操作如下：

1.搭建简单的图像识别的网络，在此基础上做fine-tuning的训练
2.在神经网络的尾端加两个头，一个分类头，一个检测头
变成了(regression + classfication)
3.regression的部分用欧式距离来计算损失，使用sgd训练
4.预测部分加两个头加在一起

思路一需要做两次fine-tuning训练，第一次在Alexnet上面做，第二次将头部改为regression head，前面不变做一次fine-tuning

Regression的部分加在哪里？
有两种处理办法：
1.加在最后一个卷积层的后面(如VGG)
2.加在最后一个全连接层的后面


## 思路2：取窗口图像
还是刚才的classification +regression的思路
咱们取不同大小的框，让框出现在不同的位置上，得出框的判定得分
取出得分最高的框
总结一下思路：
对于同一张图像来说，使用各种大小的框将图像截取出来，然后输入到cnn中，然后cnn会输出这个框的得分以及这个框对应的regression.
由于这个方法耗时太长了，
把全连接层改为卷积层，减少参数

物体检测的部分
当图像里面有很多物体怎么办
把这个问题看作是分类问题
，那么看成是分类的问题有什么不妥呢
1.你需要找出很多个位置，然后给出很多个不同大小的框
2.你还需要对于框内的图像进行 分类

但是框太多了也不行，不需要尝试那么多框的位置
有人想到了一个好办法：
找出可能包含物体的框，这些框本身是相互重叠互相包含的，这样我们就可以避免暴力枚举所有的框了。


## nms算法
NMS算法是通过抑制极大值来完成的，比如有两个矩形框，按着分类器的概率排序分别是，A,B，C,D,E,F
先取出最大的概率值的F框，然后用F框来判断是否跟前面的几个框重叠区域大于某个阈值，如果大于就舍弃掉，然后在从E开始
循环操作
```python
def nms(boxes,scores,overlap=0.5,top_k = 200):
    """Apply non-maximum suppression at test time to avoid detecting too many
    overlapping bounding boxes for a given object.
    Args:
        boxes: (tensor) The location preds for the img, Shape: [num_priors,4].
        scores: (tensor) The class predscores for the img, Shape:[num_priors].
        overlap: (float) The overlap thresh for suppressing unnecessary boxes.
        top_k: (int) The Maximum number of box preds to consider.
    Return:
        The indices of the kept boxes with respect to num_priors.
    """
    # 定义一个跟score一样长度的全为0的long类型的数据,小技巧，在tensor的后面加上.long(),.int(),.float()即可完成类型转换

    keep = scores.new(socres.size(0)).zero_().long()
    if boxes.numel() == 0:
        return keep,0
    #取出包含有坐标信息的矩阵a
    x1 = boxes[:,0]
    y1 = boxes[:,1]
    x2 = boxes[:,2]
    y2 = boxes[:,3]
    # 对应点相乘
    area = torch.mul(x2-x1,y2-y1)
    # 对于分数排序并返回排序结果和index
    v,idx = scores.sort(0)
    #从index中提取最大的topk个数值
    idx = idx[-top:]
    xx1 = boxes.new()
    yy1 = boxes.new()
    xx2 = boxes.new()
    yy2 = boxes.new()
    w = boxes.new()
    h = boxes.new()

    count = 0
    while idx.numel()>0:
        # 选出最大的概率值的框
        i = idx[-1]
        keep[count] = i
        count +=1
        if idx.size(0) ==1:
            break
        # 删除最后一行
        idx = idx[:-1]
        torch.index_select(x1,0,idx,out = xx1)
        torch.index_select(y1,0,idx,out = yy1)
        torch.index_select(x2,0,idx,out = xx2)
        torch.index_select(y2,0,idx,out = yy2)

        # 选取下一个数值最大的
        xx1 = torch.clamp(xx1,min = x1[i])
        yy1 = torch.clamp(yy1,min = y1[i])
        xx2 = torch.clamp(xx2,max = x2[i])
        yy2 = torch.clamp(yy2,max = y2[i])

        w.resize_as_(w,min = 0.0)
        h.resize_as_(h,min = 0.0)
        inter = w*h
        

        



```